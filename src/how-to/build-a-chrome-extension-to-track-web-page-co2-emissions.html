<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="How-to guide to building a Chrome extension that tracks CO2 emissions from web pages. Learn how to handle request types, use fetch API, and optimize compression rates."
    />
    <link rel="stylesheet" href="/src/styles/common.css" />
    <title>
      How to Build a Chrome Extension to Track Web Page CO2 Emissions
    </title>
  </head>
  <body class="body">
    <header>
      <h1>Build a Chrome Extension to Track Web Page CO2 Emissions</h1>
    </header>
    <main class="main">
      <h2>Architecture</h2>

      <h2>Service worker</h2>
      <ul>
        <li><code>fetch(url)</code>: Intercept the request.</li>
        <li>
          <code>response.clone()</code>: Clone the response because a Response
          object can only be consumed once. Cloning lets you to keep the
          original response intact while processing a copy.
        </li>
        <li>
          Save request information to indexedDB so that the data can be read
          back and processed e.g. grouped.
        </li>
        <li>
          The service worker messages the side panel on every request
          <em>with all requests</em>.
        </li>
      </ul>

      <h2>Side panel</h2>
      <ul>
        <li>
          <code>chrome.runtime.onMessage.addListener</code> listens for messages
          from the service worker. It is responsible for displaying a summary
          (bytes, request count, associated emissions and whether the site is
          green hosted), request details grouped by <code>type</code>, and
          listing failed requests.
        </li>
      </ul>

      <h2>Request size</h2>
      <ul>
        <li>
          We cannot use the Performance API because it only returns requests for
          the current domain and because it makes a second request to the page
          document (can you confirm this, and why?)
        </li>
        <li>
          We use content-length where it is available otherwise the byte length
        </li>
        <li>
          We use a compression matrix, given the bytes of the original,
          resource, file and the encoding type - brotli etc. in order to mimic
          what happens on the server. This is an imperfect approach but it
          allows us to approximate the number of transferred bytes.
        </li>
      </ul>
      <h3>Performance API</h3>
      <p>
        The Performance API only tracks resource timings for the current domain
        (same-origin policy). This is due to cross-origin restrictions designed
        to protect privacy and security, preventing an extension from easily
        gathering detailed request data for third-party resources. Therefore,
        <code>performance.getEntriesByType("resource")</code> will only return a
        subset of requests.
      </p>

      <h2>Real time</h2>
      <ul>
        <li>
          the extension keeps tracking emissions as new requests come in but
          will reset on page reload, when a page is refreshed or a page is
          loaded in a new tab.
        </li>
        <li>
          the first time the extension is opened after closing it is necessary
          to reload the page - there is a message to this effect because we
          don't have access to 'historical' requests (can you confirm this).
        </li>
      </ul>

      <h2>How emissions are calculated</h2>
      <h3>The Green Web Foundation (TGWF)</h3>
      <ul>
        <li>
          In order to use the
          <a href="https://developers.thegreenwebfoundation.org/co2js/methods/"
            >functions</a
          >
          provided by the <abbr title="The Green Web Foundation">TGWF</abbr>, I
          forked the
          <a href="https://github.com/thegreenwebfoundation/co2.js/">repo</a>,
          and copied the build files generated by running
          <code>npm run build</code> and imported <code>hosting</code> and
          <code>co2</code>.
        </li>
        <li>
          A call to <code>hosting.check(domain)</code> returns a boolean value
          for <code>greenHosting</code>, displayed as "green hosted".
        </li>
        <li>
          A call to <code>CO2.perByte(bytes, greenHosting)</code> returns a
          value for emissions in g of CO2.
        </li>
      </ul>
      <h2>Use cases</h2>
      There are a number of uses case we need to consider:
      <ul>
        <li>The visitor navigates to a new url in the current tab</li>
        <li>The visitor refreshes, or reloads, the current tab</li>
        <li>The visitor goes to a different, already open tab</li>
      </ul>
      In each of these scenarios we reset the db and the display:
      <ul>
        <li>Clear the indexedDB store</li>
        <li>Reset the display in the side panel</li>
        <li>Start listening for requests and update the display</li>
      </ul>
    </main>
    <footer>
      <nav aria-label="Primary">
        <a href="/src/sitemap.html">Link to human-readable sitemap in nav</a>
      </nav>
    </footer>
  </body>
</html>
